{
  "tutorials/virtuoso.html": {
    "href": "tutorials/virtuoso.html",
    "title": "Set up a Virtuoso instance",
    "keywords": "Set up a Virtuoso instance Many features of the Semiodesk.Trinity API are geared towards the Virtuoso Database . If you create a quick installation to get you started then just follow the instructions. The process is a bit different depending on the platform you are on. Windows 1. Get the latest binary distribution You can find the pre-build package on this page . 2. Unzip it to your desired location This is where your Virtuoso installation will reside, so pick a sensible directory. Inside this directory, you will have the following folders: bin contains the binaries database contains an example configuration doc contains the documentation hosting additional modules lib the libraries to access the database vad VAD packages BPEL, Conductor, tutorials, documentation 3. Set up the configuration To get started quick, you can just use the example configuration in the database folder. 4. Starting Virtuoso Here we have two options, the quickstart which creates a Virtuoso instance that stops once the console window is closed and installing Virtuoso as a Windows Service. a. Quickstart Open a console in your Virtuoso directory and start it with the following command: bin\\virtuoso-t.exe -f -c database/virtuoso.ini Closing the console or pressing ctrl-c will stop the database server. b. Installing Virtuoso as a Service This process takes a few more steps, but the Server will automatically be started when the computer is restarted. First you need a console with administration rights. The easiest way to get one is to open the start menu, type in \"cmd.exe\" and press ctrl-shift-enter. You then need to navigate into your virtuoso installation directory. To install the Service, enter bin\\virtuoso-t.exe +service screate -I \"My Virtuoso Server\" -c database/virtuoso.ini To start the Service, enter bin\\virtuoso-t.exe +service start -I \"My Virtuoso Server\" If you want to remove it from your system, you can use bin\\virtuoso-t.exe +service delete -I \"My Virtuoso Server\" 5. Testing if everything works Navigate to http://localhost:8890/conductor/ and try to login with dba/dba. If everything works you should now have a running Virtuoso server. 6. Using Virtuoso with the Semiodesk.Trinity API When you use the default configuration, you can use the following configuration string \"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\" with the Semiodesk.Trinity. To create the store, use the following snippet: #!c# IStore store = Stores.CreateStore(\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\");"
  },
  "tutorials/installation.html": {
    "href": "tutorials/installation.html",
    "title": "Installation",
    "keywords": "Installation On this page we describe the methods to install Semiodesk Trinity. Via NuGet The easiest way to install the library is via NuGet. You can install the base library with the following command: PM> Install-Package Semiodesk.Trinity.Core If you want to be able to use the object mapping features of Trinity, you should add the following package: PM> Install-Package Semiodesk.Trinity.Modelling Via Package (Not recommended)## Download the latest stable package . This archive contains everything that is needed to create a Semantic Web application with Semiodesk Trinity. Further Information For a complete introduction follow our First Steps tutorial."
  },
  "tutorials/firstSteps.html": {
    "href": "tutorials/firstSteps.html",
    "title": "First Steps",
    "keywords": "First Steps The tutorial on this page should give you a first impression what you can do with the Semiodesk Trinity API. If you follow the steps you will have a working application that already uses a lot of features that semantic web technologies can offer. You can download the finished example from http://static.semiodesk.com/semiodesk.trinity/examples/0.9/CliExample-0.9.102.zip We have prepared this example to work under Windows with the .Net platform. Different examples for Linux and Mac are not done yet but they will be published here once they are completed. This example is a simple console application that just creates and queries some data. In following examples we will show you how to do more complicated stuff. Create a project To get started we will open Visual Studio and create a new console project, lets call it \"CliExample\". Now we can start to add the dependencies using NuGet. We add the Semiodesk.Trinity.Modelling to the project. This package contains the tools that are neccessary to create the object mapping. It also has a dependency to the Semiodesk.Trinity.Core package which contains the actual library. The resulting project structure should look like this The package added a folder called Ontologies, which contains the three most basic ontologies, rdf, rdfs and owl. The App.config file has been extended to contain the configuration for Semiodesk.Trinity. Now we can start to build the domain model for our application. Add an ontology First we need to add the foundation of our modelling to the project, the ontologies. If you have been following this tutorial and asking yourself what an ontology is, don't worry. It's basically just a collection of classes and their properties formalised in a standardised way. In this example you don't have to write one yourself, we can just take an existing one. If you want to read up on the topic here is a link to the Wikipedia article . In this example we're going to use the 'Friend of a Friend' ontology, or just foaf in short. We download a XML/RDF serialised version from http://xmlns.com/foaf/spec/index.rdf and copy it into the 'Ontologies' folder in the ObjectModel project. Also to avoid confusion, we rename it to 'foaf.rdf'. Then we just need to add the file to the project in Visual Studio. Now we need to change the configuration to make the new ontology known to Semiodesk.Trinity. To make this happen, we add the following passage to the App.config under . #!xml <!--http://xmlns.com/foaf/0.1/--> <Ontology Uri=\"http://xmlns.com/foaf/0.1/\" Prefix=\"foaf\"> <FileSource Location=\"Ontologies\\foaf.rdf\"/> </Ontology> With this, we tell the framework where the ontology lies, what base uri it has and the prefix it should use for the C# class. As we want to use inferencing, we need to tell Virtuoso to use these ontologies, so we have to modify the RuleSet in the same file. Just replace the existing VirtuosoSpecific part with the following one and you are set. #!xml <VirtuosoStoreSettings> <RuleSets> <RuleSet Uri=\"urn:semiodesk/ruleset\"> <Graphs> <Graph Uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" /> <Graph Uri=\"http://www.w3.org/2000/01/rdf-schema#\" /> <Graph Uri=\"http://www.w3.org/2002/07/owl#\" /> <Graph Uri=\"http://xmlns.com/foaf/0.1/\" /> </Graphs> </RuleSet> </RuleSets> </VirtuosoStoreSettings> When you build your project now it creates the c# represenations of the ontologies in the background. Create mappings Now we want to create our domain model. We are building a small manager for people in groups. We are using the foaf ontology as a base, so we just have to create the classes according to the specification . || |---| | Note: We are currently working on a tool to automatically create a mapping from an ontology. These steps will be significantly easier in the future. | As base class for our Group and Person we want to use an Agent class. So we create a new class called Agent. #!csharp using System; using System.Collections.Generic; using Semiodesk.Trinity; namespace CliExample { [RdfClass(FOAF.Agent)] public class Agent : Resource { public Agent(Uri uri) : base(uri) { EMailAccounts = new List<Resource>(); } [RdfProperty(FOAF.name)] public string Name { get; set; } [RdfProperty(FOAF.mbox)] public List<Resource> EMailAccounts { get; set; } } } The class needs to be derived from Resource. The mapping can simply be done by decorating the class and the properties with the rdf classes and properties from the foaf ontology. || |---| | Note: There is a distinction to be made between the generated foaf class and the upper case FOAF class. The upper case version supplies the string representaion of the ontology elements and should only be used for the decorating. The lower case variant supplies Class and Property objects. | Lets now create the other two classes, Person and Group. Person is derived from Agent and has a property that models the relationship between a person and other people. #!csharp [RdfClass(FOAF.Person)] public class Person : Agent { public Person(Uri uri) : base(uri) { Knows = new List<Person>(); } [RdfProperty(FOAF.knows)] public List<Person> Knows { get; set; } } And the Group, which is also derived from Agent and contains a property modelling its membership property. #!csharp [RdfClass(FOAF.Group)] public class Group : Agent { public Group(Uri uri) : base(uri) { Member = new List<Agent>(); } [RdfProperty(FOAF.member)] public List<Agent> Member { get; set; } } Connection to the backend We want to use a Virtuoso backend for this example. It is fairly simple to set up, so just follow the instructions here . The quickstart method should be sufficient for this case. To tell Semiodesk.Trinity how to connect to the running Virtuoso instance, we need to add the following connection string to the App.config file. #!xml <connectionStrings> <add name=\"virt0\" providerName=\"Semiodesk.Trinity\" connectionString=\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba;rule=urn:semiodesk/ruleset\"/> </connectionStrings> When you build your application now, the given ontologies will be deployed to the Virtuoso instance given in the connection string. To verify this, you can look at the Virtuoso Conductor in your browser (default is http://localhost:8890 , login is dba/dba) you should be able see the new ontology graphs when you navigate to \"Linked Data\" -> \"Graphs\". The following screenshot shows how it should look like. Building the application Now we can start writing the application. First we need to do some initialization and then we can open a connection to the store. This can be done by using the name of the connection string. With the LoadOntologySettings() method we tell the store to import all ontologies from the current app.config file. In the case of the Virtuoso the ruleset is also created. #!c# SemiodeskDiscovery.Discover(); IStore store = StoreFactory.CreateStoreFromConfiguration(\"virt0\"); store.LoadOntologySettings(); Then we either create or open a model. If the model exists, we clear it, so we don't add the same information again. A model in RDF contains triples and is identified by a Uri. It can be used to group information of one domain together. #!csharp Uri modelUri = new Uri(\"http://semiodesk.com/example/cli\"); IModel model; if (store.ContainsModel(modelUri)) { model = store.GetModel(modelUri); model.Clear(); } else { model = store.CreateModel(modelUri); } Then we can start to add our mapped objects to the model. First we let the model create a new resource of type \"Person\". The empty parameter in the CreateResource() method means that we want the model to create a URI for the resource. After adding values to the resource we need to commit it to the model by calling the Commit() method. #!csharp Person john = model.CreateResource<Person>(); john.EMailAccounts.Add(new Resource(\"mailto:john.doe@example.com\")); john.Name = \"John Doe\"; john.Commit(); Group myGroup = model.CreateResource<Group>(); myGroup.Name = \"My Group\"; myGroup.Member.Add(john); myGroup.Commit(); When we want to get every Agent, meaning all Group and all Person objects, we can call ''model.GetResources (true)''. The type restricts the query to all Agent objects. With the true parameter we tell the model to infer the types from the ontologies. Because foaf:Person and foaf:Group are subclasses of foaf:Agent the query also returns the mapped objects for these classes. #!csharp foreach (Agent a in model.GetResources<Agent>(true)) { Console.WriteLine(a.Name); }"
  },
  "tutorials/intro.html": {
    "href": "tutorials/intro.html",
    "title": "Tutorials",
    "keywords": "Tutorials First Steps Learn quickly how to get started. Tutorial Music Browser A sample desktop application that lets you browse through artists and their records Tutorial Simple Unity3d Example A small Unity3d example to get you started. Tutorial Web Application with ASP.NET and SignalR Utilize Trinity to write a web application vizualizing kowledge graphs. Tutorial"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Documentation",
    "keywords": "Documentation We wanted to create a RDF API for C# and Mono that does not require the developer to work with the triple store by adding and removing triples manually. On the lowest level we offer a Resource-Property-Value interface. On the highest level, the developer can work with mapped classes. This makes the API perfect for developing user interfaces, as it supports data binding and modern application paradigms such as MVC / MVVM . Setup One of the core requirements for Semiodesk Trinity was that ontology terms need to be easily accessible from native .NET languages. If you are using the Semiodesk.Trinity.Modelling NuGet package you are ready to go. In a pre-compilation step, our framework generates a C# representation of the ontology in a the file obj/ontologies.g.cs . It creates classes for each given ontology. These classes contain basic information about the ontology: #!csharp string prefix = owl.Prefix; Uri ns = owl.Namespace; and all RDF classes and properties. #!csharp Class onto = owl.Ontology; // type contains the class with URI <http://www.w3.org/2002/07/owl#Ontology> string ontoString = OWL.Ontology; // ontoString contains the string constant \"http://www.w3.org/2002/07/owl#Ontology\" These can then be used to make queries, add values to resources or create class mappings. The convention is that lower case ontology classes (e.g. rdf) contains the Class and Property instances, upper case classes (e.g. RDF) contains the string representations neccessary for the attributes. The generation of the ontolgies can be configured in the App.config file. The following snippet shows an example how this looks like. #!xml <configuration> ... <configSections> <section name=\"TrinitySettings\" type=\"Semiodesk.Trinity.Configuration.TrinitySettings, Semiodesk.Trinity\" /> </configSections> <!-- Generate the ontology classes in the 'CliExample'-namespace --> <TrinitySettings namespace=\"CliExample\"> <OntologySettings> <!--Generate the class 'CliExample.rdf' from the contents of the file Ontologies\\rdf.rdf --> <Ontology Uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" Prefix=\"rdf\"> <FileSource Location=\"Ontologies\\rdf.rdf\" /> </Ontology> </OntologySettings> </TrinitySettings> ... </configuration> Using the namespace attribute of the TrinitySettings element you can control the CLR namespace in which the ontologies should be generated. The Uri is the namespace of the ontology. the Prefix is a shortcode for the ontology. This is used as the generated classes name. The FileSource element defines the location of the file relative to the configuration. || |---| | Note: If you are using NuGet, please be aware that if you change the framework (for example from .Net 4.5 to .Net 3.5 you need to retarget the packages. In most cases the easiest way to do that is by reinstalling them. | Store Connection A Rdf store, Triple store or simply just store represents the physical location of the data. This can either be in a database, a remote endpoint or just a temporary store in the computers memory. Establish connection to a store with #!csharp IStore store = StoreFactory.CreateStore(\"CONNECTIONSTRING\"); If you don't want to keep the connection store in code, you can define a connection string in the app.config #!xml <configuration> ... <connectionStrings> <add name=\"virt0\" providerName=\"Semiodesk.Trinity\" connectionString=\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba;rule=urn:semiodesk/ruleset\" /> </connectionStrings> ... </configuration> Then you can create a store with the followling call #!csharp IStore store = StoreFactory.CreateStoreFromConfiguration(\"virt0\"); The connection string has one fixed key, the provider . All following keys depend on the selected provider. Currently three providers are supported, OpenLink Virtuoso, SparqlEndpoints and a memory store based on dotnetrdf. It is also possible to write and load a custom store module. Loading Configuration to Store The ontologies specified in the configuration need to be loaded into the store to do things like inferencing. The method to do this is called Store.LoadOntologySettings() . Optionally it can be given the path of a configuration file. By default it will use the app.config file of the current assembly. As second parameter you can define the base directory for the ontologies. || |---| | IMPORTANT: Do not forget to set all ontologies to \"Copy always\" so they will be found at runtime. | Example: #!csharp store.LoadOntologySettings(); // Or store.LoadOntologySettings(Path.Combine(Environment.CurrentDirectory, \"myConfig.cfg\")); // Or store.LoadOntologySettings(Path.Combine(Environment.CurrentDirectory, \"myConfig.cfg\"), \"C:\\\\ontologyDir\"); It is in the responsibility of the developer to decide whether the ontologies have changed and need to be redeployed. During development it usually is no issue to do that at the start of the software. OpenLink Virtuoso This store is an excellent choice as backend if you want to host your own Semantic-enabled application. You can download the open source version of it here . The following example creates a connection to an OpenLink Virtuoso: #!csharp IStore store = StoreFactory.CreateStore(\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\"); Possible options are: host : Hostename of the server where the Virtuoso instance is being run port : Port of the Virtuoso instance. This can be looked up in the server configuration uid and pw : Credentals to access the server rule : The default ruleset for inferencing. Rulesets can be defined in the app.config like this: #!xml <configuration> ... <TrinitySettings> <VirtuosoStoreSettings> <RuleSets> <RuleSet Uri=\"urn:semiodesk/ruleset\"> <Graphs> <Graph Uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" /> </Graphs> </RuleSet> </RuleSets> </VirtuosoStoreSettings> </TrinitySettings> ... </configuration> Sparql Endpoints Sparql Endpoints offer a platform independent way to access linked data. If you just need reliable read-only access, this would be the way to go. #!csharp IStore store = StoreFactory.CreateStore(\"provider=sparqlendpoint;endpoint=http://live.dbpedia.org/sparql\"); With the only option endpoint you can define the endpoint you want to connect to. Please keep in mind that Sparql Endpoints do not support model management or data updates. Memory Store This store is great for small projects which don't need much in the way of inferencing. If you just want to load a serialized collection of triples or an ontology, this offers the most flexiblity. Just remember that you have to save the content manually before shutting down the application or everything is lost. #!csharp IStore store = StoreFactory.CreateStore(\"provider=dotnetrdf\"); Custom Store If you want to use the Trinity with a currently unsupported store, you can write a custom store provider and register it with Trinity. With the following function you can try to load the custom module. #!csharp StoreFactory.LoadProvider(\"CustomStoreProvider.dll\") The CustomStoreProvider.dll needs to contain a class derived from StoreProvider and an IStore implementation to work. Then you can create a connection to the store by calling the CreateStore function with the provider name you set. #!csharp IStore store = StoreFactory.CreateStore(\"provider=YourProviderName\"); Model Management A model can be used to group contextual data together. They create a barrier between data that can be used to separate information and controll the access to the data. For example, it makes sense to create a model for each registered user on your system, if they are not allowed to share data. These barriers can be softend tough, as it is possible to query multiple models at once. The following code snippet outlines the basic methods for managing the models in a store: #!csharp IStore store = StoreFactory.CreateStore(\"provider=virtuoso;host=localhost;port=1111;uid=dba;pw=dba\"); Uri modelUri = new Uri(\"http://localhost:8890/Models/ExampleModel\"); // Check if a model with the given URI already exists. if (store.ContainsModel(modelUri)) { // Remove the model from the store. store.RemoveModel(modelUri); } // Create an empty model in the store. store.CreateModel(modelUri); // Now we can do work with the model. IModel model = store.GetModel(modelUri); // Load the contents from a file into the model. store.Read(modelUri, new Uri(\"file://example.n3\"), RdfSerializationFormat.N3); // Write the contents of a model into a file. FileStream stream = new FileStream(\"file://example.rdf\", FileMode.Create); store.Write(stream, modelUri, RdfSerializationFormat.RdfXml); Model Groups A model group allows to make queries over multiple models at once. This is great way to blend different information sources together. Due to technical restrictions it is not possible to modify the result resources tough. They are marked as read-only and a commit will result in an error. The following code piece demonstrates how model groups work. #!csharp // create model group of two models IModelGroup modelGroup = store.CreateModelGroup(new Uri(\"ex:Test1\"), new Uri(\"ex:Test2\")); // we can use a model group like a regular model bool contains = modelGroup.ContainsResource(new Uri(\"ex:Test/testResource\")); // we can make queris on them ResourceQuery q = new ResourceQuery(nco.Contact); var res = modelGroup.GetResources(q); // we cannot change resources directly IResource resource= modelGroup.GetResource(resourceUri); // we need to get a writable represenation from the IModel test1 = store.GetModel(new Uri(\"ex:Test1\")); if( test1.ContainsResource(resource.Uri) ) resource = test1.GetResource(resource.Uri); Because of the nature of the models, it is possible that resources exist in both models at once, both with different bits of information. This is why the developer has to decide which resource he want to change and thus, which part of the information he wants to modify. Resource Management Creating new generic resources is done with the CreateResource function on the model handle. #!csharp IResource john = model.CreateResource(new Uri(\"ex:testModel/john\")); Adding Properties To add a property we use the AddProperty method. Look at the Chapter Ontology Handling to see how to use properties from an ontology. #!csharp // Without generated ontologies john.AddProperty(new Property(new Uri(\"ex:myProperty\"), \"My value\"); // With generated ontologies john.AddProperty(rdf.type, nco.Contact); john.AddProperty(nco.fullname, \"John Doe\"); Iterating over Properties To iterate over all properties, we can call the ListProperties method. To access the values, we have then have to call the ListValues method. There is also a GetValue method, which will only return the first value or null. #!csharp foreach( Property p in john.ListProperties()) { foreach( var value in john.ListValues(p) ) { Console.WriteLine(\"{0} {1} {2}\", john, p, value); } } Alternatively you can call ListValues and iterate over all Triples. #!csharp foreach( Tuple<Property, object> tuple in john.ListValues()) { Console.WriteLine(\"{0} {1} {2}\", john, tuple.Item1, tuple.Item2); } To test if a property exists in a resource, you can call HasProperty either just with a property or with a property and value to test for a combination. Removing Properties To remove a property, simply call RemoveProperty with the property and the value you want to remove. #!csharp // Without generated ontologies john.RemoveProperty(new Property(new Uri(\"ex:myProperty\")), \"My value\"); // With generated ontologies john.RemoveProperty(rdf.type, nco.Contact); john.RemoveProperty(nco.fullname, \"John Doe\"); Save Changes To persist changes in the model, they need to be comitted. Every modification in the resource is temporary until the Commit method is called. #!csharp john.Commit(); If the resource has been created by calling it's constructor and not using the IModel.CreateResource method, it can be added retroactivly by calling IModel.AddResource . The resulting copy of the resource supports the Commit method. #!csharp john2 = model.AddResource(john); Semantic Object Mapping Semiodesk Trinity offers two ways of doing class mapping. The more readable and easier one is decorating. It needs to run a post-compiler step. If you cannot do that, you can also use mapping objects. In the following we describe both ways. Note: Valid types for mapping are all base value types, DateTime, Classes derived from Resource as well as collections of these types implementing the IList interface. Decorating #!csharp [RdfClass(FOAF.Person)] public class Person : Agent { #region Constructors public Person(Uri uri) : base(uri) { } #endregion #region Mapping [RdfProperty(FOAF.firstName)] public string FirstName{ get; set; } [RdfProperty(FOAF.lastName)] public string LastName { get; set; } #endregion } The class needs to be decorated with the RDF class it is mapping. It is important that the constructor with a Uri parameter is implemented. For the actual mapping of properties, you just need to decorate them with the RDF property they should be mapped to. The getter and setter need to be empty. For the decorating you need to use the upper case prefix of the ontologies (e.g. FOAF instead of foaf) because C# only accepts static strings for decorating. Mapping objects In environments that cannot do post-build processing, it can be desirable to use the native mapping mechanism. The following example demonstrates how this works. #!csharp public class Person : Agent { #region Constructors // This constructor is neccessary public Person(Uri uri) : base(uri) { } #endregion #region Mapping // This function defines which RDF class or classes should be mapped public override IEnumerable<Class> GetTypes() { return new Class[] { foaf.Person }; } // every mapped property needs a PropertyMapping object to store the value, it needs the name of the property as well as the RDF property it mapps as parameter protected PropertyMapping<string> firstNameProperty = new PropertyMapping<string>(\"FirstName\", foaf.firstName); // The getter and setter of the property need to access the PropertyMapping object for the real value public string FirstName { get { return GetValue(firstNameProperty); } set { SetValue(firstNameProperty, value); } } protected PropertyMapping<string> lastNameProperty = new PropertyMapping<string>(\"LastName\", foaf.lastName); public string LastName { get { return GetValue(lastNameProperty); } set { SetValue(lastNameProperty, value); } } #endregion } Resource Query Inline queries are error prone, as native data types need to be serialized manually by the developer each time. With the resource query this work is done by the API. || |---| | Note: Though C# already has a concept for queries embedded in code, LINQ, we decided against it. The reason for this is because not all SPARQL expressions can be mapped to LINQ expressions. We are still evaluating the possiblities we have. | SPARQL queries are basically patterns that are matched against the graph. #!SPARQL PREFIX nco: <http://www.semanticdesktop.org/ontologies/2007/03/22/nco#> PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> DESCRIBE ?contact WHERE { ?contact rdf:type nco:Contact . ?contact nco:belongsToGroup ?group . ?group nco:contactGroupName �Family� . ?contact nco:birthDate ?birthDate . FILTER (?birthDate < \"1990-01-01\"^^xsd:date ) } This query tries to find a contact, born before 1. January 1990 and belongs to the group \"Family\". The following example shows this query in the Resource Query format. #!csharp ResourceQuery contact = new ResourceQuery(nco.PersonContact); contact.Where(nco.birthDate).LessThan(new DateTime(1990, 1, 1)); ResourceQuery group = new ResourceQuery(nco.ContactGroup); group.Where(nco.contactGroupName, \"Family\"); contact.Where(nco.belongsToGroup, group); IResourceQueryResult result = model.ExecuteQuery(contact); foreach (Resource r in result.GetResources()) { Console.WriteLine(r.Uri); } Paged Data Access Loading a large amount of resources takes some time. In most cases it is not necessary to access them all at once but only one at a time. For these cases the data can be loaded in chunks. The following example shows how it is done. #!csharp ResourceQuery q = new ResourceQuery(foaf.Person); // This also works for SparqlQueries var x = model.ExecuteQuery(q); int count = x.Count(); int pageSize = 600; int pageCount = (count + pageSize - 1) / pageSize; for (int j = 0; j < pageCount; j++) { var result = x.GetResources<Person>(j * pageSize, pageSize); foreach (Resource r in result.GetResources()) { Console.WriteLine(r.Uri); } } Data Virtualization ..."
  },
  "tutorials/musicBrowser.html": {
    "href": "tutorials/musicBrowser.html",
    "title": "Music Browser",
    "keywords": "Music Browser This examples shows you how to access the LinkedBrainz dataset with the Trinity API. It uses WinForms as UI toolkit and utilises Data binding. Linkedbrainz seems to be offline. Before you try this example check linkedbrainz.org!! You can download the finished example from http://static.semiodesk.com/semiodesk.trinity/examples/0.9/MusicBrowser.zip Because of the way NuGet works, there is one step that needs to be completed for the example to work. Open the Nuget Package Manager console (\"Tools\" -> \"NuGet Package Manager\" -> \"Package Manager Console\") and install Semiodesk.Trinity.Modelling. #! PM> Install-Package Semiodesk.Trinity.Modelling Ontologies and Object Model## As data model we've used the Music Ontology , the FOAF and the DCES . For the object model we have created representations of the artist as well as his created works. || |---| | Note: As you can see, there is no connection between MusicArtist and Release. In this example we have solved the latency problem by wrapping this request in a separate query. | Accessing Sparql Endpoints To query the endpoint we need to create a store with the appropriate parameters. #!csharp IStore _store = StoreFactory.CreateStore(\"provider=sparqlendpoint;endpoint=http://linkedbrainz.org/sparql\"); IModel _model = _store.GetModel(new Uri(\"http://linkedbrainz.org/sparql\")); We use the Sparql Endpoint provider and configure the endpoint adress at http://linkedbrainz.org/sparql . Data binding Though a bit rudimentary, data binding is possible in Winforms. We have created two ListBoxes which are displaying the Title property of our resources. This can be done by setting the DisplayMember Property of the ListBox. As datasource we create a VirtualizingResourceCollection and set it to the ListBoxes DataSource. #!csharp ResourceQuery artistEntity = new ResourceQuery(artist); // Artist is the concrete artist resource. ResourceQuery madeEntity = new ResourceQuery(mo.Release); artistEntity.Where(foaf.made, madeEntity); albumListBox.DataSource = new VirtualizingResourceCollection<Release>(Model, madeEntity); Loading Data in Parallel We have used the async/await pattern to keep the UI responsive during querying. As threading is not an issue when using a SPARQL endpoint there is no need to worry about connection pooling."
  },
  "tutorials/license.html": {
    "href": "tutorials/license.html",
    "title": "License",
    "keywords": "License The Semiodesk.Trinity library and tools found in this repository are licensed under the the MIT License (MIT). Copyright (c) 2015 Semiodesk GmbH Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "index.html": {
    "href": "index.html",
    "title": "Semiodesk Trinity",
    "keywords": "Semiodesk Trinity Trinity is an application development platform for Microsoft .NET and Mono. It allows to easily build Linked Data and Semantic Web applications based on the RDF metadata standard issued by the W3C. The API allows for developing first-class .NET applications with direct access to Linked Open Data repositories and knowledge bases such as DBPedia, Freebase, Geonames, BBC Business News, BBC Sports and many more. Benefits Semiodesk Trinity is based on the Resource Description Framework (RDF) linked data platform, which is an open standard maintained by the World Wide Web Consortium (W3C). This means your data is vendor-independent and will be easily accessible and exchangable in many years to come. Compared to many propriety graph databases, it has some considerable advantages: Standardized Graph Data Model RDF extends the linking structure of the Word Wide Web to name things and the relationships between them. Using this simple model, it allows structured and semi-structured data to be mixed, exposed, and shared across different applications. Ontologies: Class & Property Inheritance Ontologies provide a powerful way to describe classes and their properties in RDF. In contrast to many established data modelling frameworks, ontologies also allow to define inheritance relationships amongst properties. Since ontologies are part of the data graph, this can happen during application rutime. Powerful & Intuitive Query Language Trinity supports Linq queries for your mapped objects. Developers familiar with this way of writing queries won't need to change their approach. For people who require more specialized query, it is always possible to use SPARQL. Logical Inferencing Ontologies provide rich knowledge about data structure, such as sub-class, sub-property hierarchies and about the transitivity of properties. Many RDF databases can make use of logical reasoning during application runtime to answer queries about facts which have not been explicitly saved. License The library and tools in this repository are all released under the terms of the MIT license. This means you can use it for all kinds of projects, including commercial ones. The source code, documentation and issue tracking can be found at our Github project page. If you like what we are doing and want to support us, please consider donating. Technical Support If you encounter problems with Semiodesk Trinity you can use our issue tracking system. If you are interested in priority support or need some technical expertise, you can contact us under hello@semiodesk.com or through the contact page. Please join our public mailing list to ask questions and for sharing ideas of any kind. Community & Contributing We'd like to encourage anyone who is interested in using or contributing to Trinity to join our public mailing list for discussing anything related to this project. If you want to contribute source code, please make sure that you have all the rights for publication under a MIT license and create a pull request at our Github project site."
  },
  "tutorials/webApp.html": {
    "href": "tutorials/webApp.html",
    "title": "Web Application",
    "keywords": "Web Application This example demonstrate how to use Semiodesk Trinity with ASP.NET MVC 5 and SignalR. The resulting application is able to generate random people and connections between them. The web page visualizes the dependencies in a graph with D3js . You can download the finished example from http://static.semiodesk.com/semiodesk.trinity/examples/0.9/WebApp.zip Because of the way NuGet works, you have to add the Semiodesk Trinity packages manually. Open the Nuget Package Manager console (\"Tools\" -> \"NuGet Package Manager\" -> \"Package Manager Console\") and install Semiodesk.Trinity.Modelling to the DataModel Project and Semiodesk.Trinity.Core to the EbApp. #! PM> Install-Package Semiodesk.Trinity.Modelling -ProjectName DataModel PM> Install-Package Semiodesk.Trinity.Core -ProjectName WebApp Also, you might need to configure the Virtuoso connection string in the Web.config file appropriately. Architecture and Object Model Overview To separate the data model from the application I have created a project that only contains the ontologies and the mapped classes. To keep things simple, I used the foaf ontology again. The mapping is nearly the same as the first steps example . As we want to serialize our objects to Json we need to change it a bit. Serializers often have limitation when it comes to possible dependency cycles. We need to handle the Knows relationship differently than before. To prevent loops we hide the Knows property from the serializer with JsonIgnore and create a new property that only exposes the URIs of the related objects. That way we can still access the objects, but only when we actively decide to do so. #!csharp [RdfProperty(FOAF.knows), JsonIgnore] public List<Person> Knows { get; set; } public IEnumerable<Uri> knows { get { return from x in Knows select x.Uri; } } To make the data available, I have implemented the repository pattern under Models/ResourceRepository.cs . This is used to create an additional abstraction layer between the database and it's peculiarities and the application logic. Displaying the Data The actual data is not rendered directly to html, but queried by the Javascript code that is deployed using ASP.NET. Creating a data backend is very easy using the aforementioned repository pattern and SignalR . This has the advantage that the data can be loaded asynchronously, while the web page is already displayed. The following diagram shows the full process how the data is acquired. The result is then transformed to create a visualisation with D3. Checklist Things to consider when you build a new project with ASP.NET and Trinity: Add SemiodeskDiscovery.Discover(); to Global.asax.cs -- Application_Start() Get ResourceRepository.cs and StoreFactory.cs from this example, they are generic and make your life easier. While creating the mapping classes, think about serialization issues. If you have trouble with SignalR, use ``` #!javascript $.connection.hub.logging = true;"
  },
  "tutorials/simpleUnity.html": {
    "href": "tutorials/simpleUnity.html",
    "title": "Simple Unity Example",
    "keywords": "Simple Unity Example There are a number of use cases where semantic web technology makes a lot of sense in a gaming engine. In this first example we do not want bother ourselves to much with persistence. We look at how, in general, the Semiodesk Trinity platform can be used in combination with the Unity3d framework. A few restrictions apply: Modelling/Object Mapping should be done in a separate project .Net 3.5 only Requirements for this example: Basic knowledge about Unity3D Knowledge about C# and threading (BackgroundWorker) What does this Example do This is a small \"game\" which lists all books of a series on the press of a button. In this example it's the Lord of the Rings. It follows the links of the subsequent works. We start out with a hard coded link to the book \" The Fellowship of the Ring \". The property \" dbo:subsequentWork \" links all three books of the trilogy together. What are the problem of this example? Dbpedia data does not always follow ontologies. We use for this example the Lord of the Rings trilogy. If we were to exchange that for Harry Potter books, it doesn't work because the links are not there. Well, thats generated data for you. Downloading the finished Project I know, a lot of people want to skip ahead and see what the result looks like. You can download the result from the following link: http://static.semiodesk.com/semiodesk.trinity/examples/0.9/SimpleDbpedia.zip Because of the way NuGet works, there is one step that needs to be completed for the example to work. Open the Nuget Package Manager console (\"Tools\" -> \"NuGet Package Manager\" -> \"Package Manager Console\") and install Semiodesk.Trinity.Modelling. #! PM> Install-Package Semiodesk.Trinity.Modelling -source http://nuget.semiodesk.com/api/v2/ Make a release build before you open the project in Unity. You can find the scene under Assets/Scenes/Simple.scene . Getting started First you need to set up a new Unity3d Project. Next to the Assets folder you can put a new folder for the ontology mapping project. I usually call it External. Here we create a new C# Library project (create it either in Visual Studio or XamarinStudio/Monodevelop). To make the results of this projects available our Unity projects, we need to set the build output (preferably of the release build) to ..\\..\\Assets\\Plugins\\ The Plugins directory is a special folder of unity which treats the contained DLLs differently. Adding Semiodesk Trinity Now we can add the Semiodesk.Trinity.Modelling package to the project by executing the following command in the Package Manager Console ( Tools -> NuGet Package Manager -> Package Manager Console ). || |---| | IMPORTANT: We currently have some issues with our dependencies. The current version of OpenLink.Data.Virtuoso.dll is not comaptible with Mono. This is why we decided to switch back to the old version. As this change is not in the release branch at the moment, it is neccessary to use the development branch. | #! PM> Install-Package Semiodesk.Trinity.Modelling -source http://nuget.semiodesk.com/api/v2/ Then you need to manually remove the references to virtado3, dotNetRDF.Data.Virtuoso and OpenLink.Data.Virtuoso as these are not compatible with Unity3D. Adding the dbpedia ontology I have picked up the dbpdia ontology from this link . The next step is to extract it to the ontologies directory. Then we need the foaf ontology which I stored as foaf.rdf in the ontologies directory. Then we can add the following part to the OntologySettings section in the App.config #!xml <Ontology Uri=\"http://dbpedia.org/ontology/\" Prefix=\"dbo\"> <FileSource Location=\"Ontologies\\dbpedia_2015-04.nt\"/> </Ontology> <Ontology Uri=\"http://xmlns.com/foaf/0.1/\" Prefix=\"foaf\"> <FileSource Location=\"Ontologies\\foaf.rdf\" /> </Ontology> Create object mapping Now we add the C# classes for the mappings we want. For example we want information about written works: #!csharp [RdfClass(DBO.WrittenWork)] public class WrittenWork : Resource { #region Constructor public WrittenWork(Uri uri) : base(uri) {} public WrittenWork(Resource other) : base(other) {} public WrittenWork(string uriString) : base(uriString) {} #endregion #region Properties [RdfProperty(FOAF.name)] public string Name { get; set; } [RdfProperty(DBO.previousWork)] public List<WrittenWork> PreviousWork { get; set; } [RdfProperty(DBO.subsequentWork)] public List<WrittenWork> SubsequentWork { get; set; } [RdfProperty(DBO.author)] public Person Author { get; set; } #endregion } To get information about the author, we need a mapping for foaf:Person #!csharp [RdfClass(FOAF.Person)] public class Person : Resource { public Person(Uri uri) : base(uri) {} [RdfProperty(FOAF.name)] public string Name { get; set; } [RdfProperty(FOAF.surname)] public string Surname { get; set; } [RdfProperty(FOAF.givenname)] public string GivenName { get; set; } } For convenience we also create a DataStore class which connects to the store on creation. #!csharp public class DataStore { #region Members Uri _endpoint = new Uri(\"http://live.dbpedia.org/sparql\"); IStore _store; public IStore Store { get { return _store; } } #endregion #region Constructor public DataStore() { SemiodeskDiscovery.Discover(); _store = StoreFactory.CreateStore(\"provider=sparqlendpoint;endpoint=http://live.dbpedia.org/sparql\"); } #endregion } Integration into Unity3d To get the Trinity running in Unity3D you first need to set the Api Compatibility Level to .NET 2.0 Subset . For this, open the Player settings in Unity3D (Edit -> Project Settings -> Player) and change the appropriate entry. When the DataModel project is now being built in release mode, Unity should automatically pick it up and make it available for scripting. Adding a simple interaction For this example we just need a Canvas with a Button and a Text control. Add them to your scene (GameObject -> UI -> Canvas / Button / Text). Now we add the querying mechanism by adding a script to the canvas. For this, just select the canvas and in the Inspector click Add Component -> New Script and make sure Csharp is selected. We call this script LoadData and add the following code to it. #!csharp using UnityEngine; using UnityEngine.UI; using System.Collections; using DataModel; using Semiodesk.Trinity; using System; using System.ComponentModel; using System.Collections.Generic; public class LoadData : MonoBehaviour { public Text Target; DataStore _store; IModel _model; BackgroundWorker _worker; Queue<Action> _actions = new Queue<Action>(); WrittenWork _currentBook; Uri _targetBook; // Use this for initialization void Start () { _targetBook = new Uri (\"http://dbpedia.org/resource/The_Fellowship_of_the_Ring\"); _store = new DataStore (); _model = _store.Model; _worker = new BackgroundWorker (); _worker.DoWork += (object sender, DoWorkEventArgs e) => ExecuteLoad(); } // Update is called once per frame void Update () { lock (_actions) { if( _actions.Count > 0 ) { _actions.Dequeue().Invoke(); } } } public void StartLoading() { _worker.RunWorkerAsync (); } void ExecuteLoad() { if (_currentBook == null) { _currentBook = _model.GetResource<WrittenWork> (_targetBook, null); } else { var works = _currentBook.SubsequentWork; if( works.Count > 0 ) _currentBook = works[0]; } if (_currentBook != null) { lock(_actions) { _actions.Enqueue (new Action (() => Target.text = _currentBook.Name)); } } } void OnDestroy() { _worker.Dispose (); } } Now we just need to set the Button to call the appropriate function. Select it and set the On Click() handler like in the following image. || |---| | Note: Even tough the setting of Target.text does not seem like a call to Unity method, it could be property that calls methods which are not allowed to be called from a thread. To be safe, relay as much as possible back to the UI thread. | The result You now have a small game that gives you the title of all three parts of The Lord of the Rings if you press the button repeatedly. Yay for Semantic Web!"
  }
}